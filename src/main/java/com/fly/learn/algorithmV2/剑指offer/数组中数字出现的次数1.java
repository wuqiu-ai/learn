package com.fly.learn.algorithmV2.剑指offer;

/**
 * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
 *
 *  
 *
 * 示例 1：
 *
 * 输入：nums = [4,1,4,6]
 * 输出：[1,6] 或 [6,1]
 * 示例 2：
 *
 * 输入：nums = [1,2,10,4,1,4,3,3]
 * 输出：[2,10] 或 [10,2]
 *  
 *
 * 限制：
 *
 * 2 <= nums.length <= 10000
 *
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 * @author: peijiepang
 * @date 2021/5/26
 * @Description:
 */
public class 数组中数字出现的次数1 {

    /**
     * 题解思路： 已知：两数相等异或结果为0，一个数与0异或结果就等于其本身。所以如果数组中只有一个出现一次的数，
     * 那么就只需要对所有的数进行异或就可以得到这个只出现一次的数，而本题中出现一次的数有两个。
     * 所以所有数异或的结果就是那两个只出现一次的数异或的结果。所以根据这个特性，我们就可以采用分组的方法解决此问题。
     * 且分组要满足两个条件。1、两个相同的数必须出现在同一组。2、那两个只出现一次的数必须分配在不同的组。
     * 这样我们分别对这两组数进行异或，就可以得到两个出现一次的数。那么，究竟应该怎么分组呢？
     * 例如【4,1,4,6】:全部异或的结果就是1和6异或的结果。就是0001和0110异或的结果0111。其实我们不难发现。
     * 将该两个相同的数分配在一组是很容易实现的。我们只需要固定一个二进制位，若这两个数在这个二进制位上的数是相同的。我
     * 们就把他分在同一组。但是难点还是在如何实现将两个子出现一次的数分配在不同的组里面。往下分析，
     * 1和6异或结果就是0111，0111这个二进制数中是1的二进制位暗含了什么个意思呢？分析不难知道，二进制位是1，
     * 就表示1和6在这个二进制位上的数是不同的。所以，这就是我们划分两个数到不同组的依据。因为0111有三个二进制位都是1，
     * 分别是第一位、第二位、第三位。这就表示了1和6的二进制数在第一、二、三位上的数是不同的。我们假设就以第一个二进制位为划分标准。
     * 当数组中的数的第一个二进制位是1的就分为第一组。数组中的数第一个二进制位是0的就划分为第二组。这样就成功的将1和6分到了不同的组别中，
     * 而相同的数例如4，因为4和4的第一个二进制位是必然相等的，这样也就实现了将两个相同的数划分到同一组。最后只需要分别将这两个组进行异或，就可以得到我们要求的答案
     * @param nums
     * @return
     */
    public int[] singleNumbers(int[] nums) {
        int ret = 0;
        for(int num:nums){
            ret ^= num;//ret最终答案就是那两个只出现一次的的数异或的结果
        }
        //找到ret二进制数中第几位是1
        int target = 1;//初始位0001
        while((target & ret)==0){//如果target第一个二进制位不为1，就将target左移一位位0010，然后与相与，判断ret第二位是否为一.按此循环，知道找到ret的第一个为1的二进制位
            target = target<<1;
        }
        int a = 0, b = 0;
        for(int num:nums){
            if((num & target)==0){//第一组
                a ^= num;
            }else{//第二组
                b ^= num;
            }
        }
        return new int[]{a,b};
    }

}
